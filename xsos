#!/bin/bash
# xsos v1.0.0dev last mod 2015/07/10
# Latest version at <http://github.com/ryran/xsos>
# RPM packages available at <http://people.redhat.com/rsawhill/rpms>
# Copyright 2012-2015 Ryan Sawhill Aroha <rsaw@redhat.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------

# Get version from line #2
version=$(sed '2q;d' $0)

# Colors and colors and colors oh my (but only for bash v4)
if [[ $BASH_VERSINFO -ge 4 ]]; then
  declare -A c
  c[reset]='\033[0;0m'   c[BOLD]='\033[0;0m\033[1;1m'
  c[dgrey]='\033[0;30m'  c[DGREY]='\033[1;30m'  c[bg_DGREY]='\033[40m'
  c[red]='\033[0;31m'    c[RED]='\033[1;31m'    c[bg_RED]='\033[41m'
  c[green]='\033[0;32m'  c[GREEN]='\033[1;32m'  c[bg_GREEN]='\033[42m'
  c[orange]='\033[0;33m' c[ORANGE]='\033[1;33m' c[bg_ORANGE]='\033[43m'
  c[blue]='\033[0;34m'   c[BLUE]='\033[1;34m'   c[bg_BLUE]='\033[44m'
  c[purple]='\033[0;35m' c[PURPLE]='\033[1;35m' c[bg_PURPLE]='\033[45m'
  c[cyan]='\033[0;36m'   c[CYAN]='\033[1;36m'   c[bg_CYAN]='\033[46m'
  c[lgrey]='\033[0;37m'  c[LGREY]='\033[1;37m'  c[bg_LGREY]='\033[47m'
fi

# ==============================================================================
# ENVIRONMENT VARIABLES -- Modify these by setting them in your shell
# environment, e.g. ~/.bash_profile or /etc/profile.d/xsos.sh

# XSOS_IMPORT_PATH (colon-delimited array of directory paths)
#   xsos was split into multiple files starting with xsos v1
#   These directories will be searched (in order) for modules
    : ${XSOS_IMPORT_PATH:="./modules:$HOME/.local/share/xsos:/usr/share/xsos"}

# COLORS
# The following configure defaults for various colors to enhance output

#   XSOS_COLORS (bool: y/n)
#     Controls whether color is enabled or disabled by default
#     Can also be controlled by cmdline arg
      : ${XSOS_COLORS:="y"}

#   XSOS_COLOR_RESET -- color to reset terminal to after using other colors
      : ${XSOS_COLOR_RESET:="reset"}

#   XSOS_COLOR_H1 -- color for content modules' primary header
      : ${XSOS_COLOR_H1:="RED"}

#   XSOS_COLOR_H2 -- color for content modules' secondary header
      : ${XSOS_COLOR_H2:="PURPLE"}

#   XSOS_COLOR_H3 -- color for content modules' tertiary header
      : ${XSOS_COLOR_H3:="BLUE"}

#   XSOS_COLOR_H4 -- color used only for SYSCTL() module
      : ${XSOS_COLOR_H4:="reset"}

#   XSOS_COLOR_IMPORTANT -- color for drawing attention to important data
      : ${XSOS_COLOR_IMPORTANT:="BOLD"}

#   XSOS_COLOR_WARN1 -- color for level-1 warnings
      : ${XSOS_COLOR_WARN1:="orange"}

#   XSOS_COLOR_WARN2 -- color for level-2 warnings
      : ${XSOS_COLOR_WARN2:="ORANGE"}

#   XSOS_COLOR_MEMGRAPH_MEMUSED -- color for MemUsed in MEM() graph
      : ${XSOS_COLOR_MEMGRAPH_MEMUSED:="green"}

#   XSOS_COLOR_MEMGRAPH_HUGEPAGES -- color for HugePages in MEM() graph
      : ${XSOS_COLOR_MEMGRAPH_HUGEPAGES:="cyan"}

#   XSOS_COLOR_MEMGRAPH_BUFFERS -- color for Buffers in MEM() graph
      : ${XSOS_COLOR_MEMGRAPH_BUFFERS:="purple"}

#   XSOS_COLOR_MEMGRAPH_CACHED -- color for Cached in MEM() graph
      : ${XSOS_COLOR_MEMGRAPH_CACHED:="blue"}

#   XSOS_COLOR_MEMGRAPH_DIRTY -- color for Dirty in MEM() graph
      : ${XSOS_COLOR_MEMGRAPH_DIRTY:="red"}

#   XSOS_COLOR_IFUP -- color for ethtool InterFace "up"
      : ${XSOS_COLOR_IFUP:="green"}

#   XSOS_COLOR_IFDOWN -- color for ethtool InterFace "down"
      : ${XSOS_COLOR_IFDOWN:="lgrey"}

# INDENTATION
#   The following variables are not used universally and that might not change

#   XSOS_INDENT_H1 -- 1st level of indentation
      : ${XSOS_INDENT_H1:="  "}

#   XSOS_INDENT_H2 -- 2nd level of indentation
      : ${XSOS_INDENT_H2:="    "}

#   XSOS_INDENT_H3 -- 3rd level of indentation
      : ${XSOS_INDENT_H3:="      "}

# XSOS_FOLD_WIDTH (w, 0, or positive number)
#   Some content modules print line of unpredictable length
#   This setting controls the wrapping width for commands that use it
#   Changing to w causes width of terminal to be used
#   Changing to 0 causes 99999 to be used
    : ${XSOS_FOLD_WIDTH:="w"}

# XSOS_HEADING_SEPARATOR (str)
#   Acts as a separator between content modules
#   Should include at least 1 trailing new-line
    : ${XSOS_HEADING_SEPARATOR:="\n"}

# XSOS_ALL_VIEW (str of variables, space-separated)
#   Controls what content modules to run when -a/--all switch is used
    : ${XSOS_ALL_VIEW:="bios os kdump cpu intrupt mem disks mpath lspci ethtool softirq bonding ip netdev sysctl ps"}

# XSOS_DEFAULT_VIEW (str of variables, space-separated)
#   Controls default content modules, i.e. what to run when none are specififed
    : ${XSOS_DEFAULT_VIEW:="os"}

# XSOS_PS_THREADS (bool: y/n)
#   Controls whether PS() function parses `ps aux` or `ps auxm` output
    : ${XSOS_PS_THREADS:="n"}

# XSOS_PS_LEVEL (int: 0-4)
#   Controls verbosity level (4 being highest) in PS() function
    : ${XSOS_PS_LEVEL:="1"}

# XSOS_MULTIPATH_QUERY (string: arbitrary regex)
#   Only a tenuous case can be made for statically setting this
#   It's used by the MULTIPATH() function to restrict display to a particular mpath device
#   Traditionally controled by -q/--wwid option
    : ${XSOS_MULTIPATH_QUERY:=""}

# XSOS_MEM_UNIT (str: b, k, m, g, t)
#   Sets unit used by MEM() function for printing
#   Can also be controlled by cmdline opt -u/--unit
    : ${XSOS_MEM_UNIT:="g"}

# XSOS_NET_UNIT (str: b, k, m, g, t)
#   Sets unit used by NETDEV() function for printing Rx & Tx Bytes
#   Can also be controlled by cmdline opt -u/--unit
    : ${XSOS_NET_UNIT:="m"}

# XSOS_PS_UNIT (str: k, m, g)
#   Sets unit used by PS() function for printing VSZ & RSS
#   Not affected by cmdline opt -u/--unit option
    : ${XSOS_PS_UNIT:="m"}

# XSOS_OUTPUT_HANDLER (str: application name)
#   Sets name of application to handle output
    : ${XSOS_OUTPUT_HANDLER:="cat"}

# XSOS_OS_RHT_CENTRIC (bool: y/n)
#   Configures whether OS() focuses on Red Hat support issues
    : ${XSOS_OS_RHT_CENTRIC:="n"}

# XSOS_IP_VERSION (int: 4/6)
#   Configures whether IP() shows ipv4 or ipv6 addresses
    : ${XSOS_IP_VERSION:="4"}

# XSOS_SCRUB_IP_HN (bool: y/n)
#   Configures whether IP addrs & hostnames should be removed from output
    : ${XSOS_SCRUB_IP_HN:="n"}

# XSOS_SCRUB_MACADDR (bool: y/n)
#   Configures whether HW MAC addresses should be removed from output
    : ${XSOS_SCRUB_MACADDR:="n"}

# XSOS_ETHTOOL_ERR_REGEX (str: regular expression)
#   Configures what ETHTOOL() uses to generate the data under the "Interface Errors" heading
    : ${XSOS_ETHTOOL_ERR_REGEX:="(drop|disc|err|fifo|buf|fail|miss|OOB|fcs|full|frags|hdr|tso|pause).*: [^0]"}

# XSOS_LSPCI_NET_REGEX (str: regular expression)
#   Configures what LSPCI() uses to search for peripherals under the "Net" heading
    : ${XSOS_LSPCI_NET_REGEX:="(Ethernet controller|Network controller|InfiniBand):"}

# XSOS_LSPCI_STORAGE_REGEX (str: regular expression)
#   Configures what LSPCI() uses to search for peripherals under the "Storage" heading
    : ${XSOS_LSPCI_STORAGE_REGEX:="(Fibre Channel|RAID bus controller|Mass storage controller|SCSI storage controller|SATA controller|Serial Attached SCSI controller):"}

# ==============================================================================


VERSINFO() {
  echo "Version info: ${version:2}
See <github.com/ryran/xsos> to report bugs or suggestions"
  exit
}

HELP_USAGE() {
  echo "Usage: xsos [DISPLAY OPTIONS] [-6abokcfmdtlerngisp] [SOSREPORT ROOT]
  or:  xsos [DISPLAY OPTIONS] {--B|--C|--F|--M|--D|--T|--L|--R|--N|--G|--I|--P FILE}...
  or:  xsos [-?|-h|--help]

Display system info from localhost or extracted sosreport"
}

HELP_OPTS_CONTENT() {
  echo "
Content options:"
  echo "
 -a, --all❚show everything
 -b, --bios❚show info from dmidecode
 -o, --os❚show hostname, distro, SELinux, kernel info, uptime, etc
 -k, --kdump❚inspect kdump configuration
 -c, --cpu❚show info from /proc/cpuinfo
 -f, --intrupt❚show info from /proc/interrupts
 -m, --mem❚show info from /proc/meminfo
 -d, --disks❚show info from /proc/partitions + dm-multipath synopsis
 -t, --mpath❚show info from dm-multipath
 -l, --lspci❚show info from lspci
 -e, --ethtool❚show info from ethtool
 -r, --softirq❚show info from /proc/net/softnet_stat
 -n, --netdev❚show info from /proc/net/dev
 -g, --bonding❚show info from /proc/net/bonding
 -i, --ip❚show info from ip addr (BASH v4+ required)
     --net❚alias for: --lspci --ethtool --softirq --netdev --bonding --ip
 -s, --sysctl❚show important kernel sysctls
 -p, --ps❚inspect running processes via ps" | column -ts❚
}

HELP_OPTS_DISPLAY() {
  echo "
Display options:"
# --rhsupport❚tweak os output to focus on RHEL-centric support issues
  echo "
     --scrub-ip❚remove IP addresses & hostnames from output
     --scrub-mac❚remove HW MAC addresses from output
                ❚see XSOS_SCRUB_IP_HN & XSOS_SCRUB_MACADDR env vars
 -6, --ipv6❚parse ip addr output for IPv6 addresses instead of IPv4
 -q, --wwid=ID❚restrict dm-multipath output to a particular mpath device,
              ❚where ID is a wwid, friendly name, or LUN identifier
 -u, --unit=P❚change byte display for /proc/meminfo & /proc/net/dev,
             ❚where P is \"b\" for byte, or else \"k\", \"m\", \"g\", or \"t\"
     --threads❚make ps take threads into account (via \`ps auxm\`)
 -v, --verbose=NUM❚specify ps verbosity level (0-4, default: 1)
 -w, --width=NUM❚change fold-width, in columns (positive number, e.g., 80)
                ❚\"0\" disables wrapping, \"w\" autodetects width (default)
 -x, --nocolor❚disable output colorization
 -y, --less❚send output to \`less -SR\`
 -z, --more❚send output to \`more\`" | column -ts❚
}

HELP_OPTS_SPECIAL() {
  echo "
Special options (BASH v4+ required):"
  echo "
 --B=FILE❚read from FILE containing \`dmidecode\` dump
 --C=FILE❚read from FILE containing /proc/cpuinfo dump
 --F=FILE❚read from FILE containing /proc/interrupts dump
 --M=FILE❚read from FILE containing /proc/meminfo dump
 --D=FILE❚read from FILE containing /proc/partitions dump
 --T=FILE❚read from FILE containing \`multipath -v4 -ll\` dump
 --L=FILE❚read from FILE containing \`lspci\` dump
 --R=FILE❚read from FILE containing /proc/net/softnet_stat dump
 --N=FILE❚read from FILE containing /proc/net/dev dump
 --G=FILE❚read from FILE containing /proc/net/bonding/xxx dump
 --I=FILE❚read from FILE containing \`ip addr\` dump
 --P=FILE❚read from FILE containing \`ps aux\` dump" | column -ts❚
}

HELP_SHORT() {
  HELP_USAGE
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  HELP_OPTS_SPECIAL
  echo -e "\nRun with \"--help\" to see full help page\n"
  VERSINFO
}

HELP_EXTENDED() {
  HELP_USAGE
  echo "Run with \"-h\" to see simplified help page"
  HELP_OPTS_CONTENT
  HELP_OPTS_DISPLAY
  echo "
If no content options are specified, xsos parses the environment variable
XSOS_DEFAULT_VIEW to figure out what information to display. If this variable
is unset at runtime, it is initialized internally as follows:

   XSOS_DEFAULT_VIEW='os'

Tweak it to preference by adding additional space-separated MODULE statements,
where MODULE is the same as the long option (e.g. mem, ethtool, netdev). Note
that the --net alias option cannot be used for this purpose. Also note that the
-a / --all option has it's own environment variable: XSOS_ALL_VIEW

If SOSREPORT ROOT isn't provided, the data will be gathered from the localhost;
however, bios, multipath, and ethtool output will only be displayed if running
as root (UID 0). When executing in this manner as non-root, those modules will
be skipped, and a warning printed to stderr.

Sometimes a full sosreport isn't available; sometimes you simply have a
dmidecode-dump or the contents of /proc/meminfo and you'd like a summary..."
  HELP_OPTS_SPECIAL
  echo "
As is hopefully clear, each of these options requires a filename as an
argument. These options can be used together, but cannot be used in concert
with regular \"Content options\" -- Content opts are ignored if Special options
are detected. Also note: the \"=\" can be replaced with a space if desired.

Re BASH v4+:
 BASH associative arrays are used for various things. In short, if running
 xsos on earlier BASH versions (e.g. RHEL5), you get ...
  * No output colorization
  * No -i/--ip
  * No parsing of \"Special options\"

Environment variables:
 For details of all configurable env variables, view first page of xsos
 source. There are vars to change default colors as well as other settings.
 Each variable name is prefixed with \"XSOS_\" and the important ones follow.
  COLORS  FOLD_WIDTH  ALL_VIEW  DEFAULT_VIEW  HEADING_SEPARATOR  IP_VERSION
  MEM_UNIT  NET_UNIT  PS_UNIT  PS_LEVEL  PS_THREADS  OUTPUT_HANDLER
  SCRUB_IP_HN  SCRUB_MACADDR  ETHTOOL_ERR_REGEX XSOS_IMPORT_PATH
"
  VERSINFO
}

WARN_NO_UPDATE() {
  echo "Warning: v0.6.0 dropped the built-in update feature triggered by -U/--update"
  echo "Future v1.x versions might repurpose the -U option"
  echo "See https://github.com/ryran/xsos/issues/155 for more info"
  exit 64
}

# Help? Version?
case $1 in
  -V|--vers|--version)  echo "Version info: ${version:2}"; exit ;;
  -\?|-h)               HELP_SHORT ;;
  --help|help)          HELP_EXTENDED ;;
  -U|--update)          WARN_NO_UPDATE >&2 ;;
esac

# GNU getopt short and long options:
sopts='6q:u:v:w:xyzabokcfmdtlerngisp'
lopts='scrub-ip,scrub-mac,ipv6,rhsupport,wwid:,unit:,threads,verbose:,width:,nocolor,less,more,all,bios,os,kdump,cpu,intrupt,mem,disks,mpath,lspci,ethtool,softirq,netdev,bonding,ip,net,sysctl,ps,B:,C:,F:,M:,D:,T:,L:,R:,N:,G:,I:,P:'

# Check for bad switches
getopt -Q --name=xsos -o $sopts -l $lopts -- "$@" || { HELP_USAGE; exit 64; }

# Setup assoc array for single-file options
unset sfile
[[ $BASH_VERSINFO -ge 4 ]] && declare -A sfile

# Checker for cmdline options
_OPT_CHECK() {
  local option chosen_opt check_type valid_opts n s
  option=$1
  chosen_opt=$(tr '[:upper:]' '[:lower:]' <<<"$2")
  check_type=$3
  valid_opts=$4
  if [[ $check_type == regex ]]; then
    egrep -qs "$valid_opts" <<<"$chosen_opt" && return
    case $option in
      width)
        echo "xsos: option '$option' expects a positive number or 'w' (auto-detect width) or '0' (disable wrapping)"
        ;;
      *)
       echo "xsos: option '$option' expects other input, i.e., matching regex '$valid_opts'"=
    esac
  
  elif [[ $check_type == range ]]; then
    for n in $(seq $valid_opts); do
      [[ $n == $chosen_opt ]] && return
    done
    echo "xsos: option '$option' expects number from range: { ${valid_opts// /-} }"
    
  elif [[ $check_type == naturalnumber ]]; then
    egrep -qs '^[0-9]+$' <<<"$chosen_opt" && return
    echo "xsos: option '$option' expects any natural number, including zero"
    
  elif [[ $check_type == string ]]; then
    for s in $valid_opts; do
      [[ $s == $chosen_opt ]] && return
    done
    echo "xsos: option '$option' expects one of: { $valid_opts } "
  
  elif [[ $check_type == anystring ]]; then
    [[ -n $2 ]] && return
    echo "xsos: option '$option' expects a non-null string value"
  fi
  
  exit 64
}


# Parse command-line arguments
PARSE() {
  unset opts all bios os kdump cpu intrupt mem disks mpath lspci ethtool softirq netdev bonding ip net sysctl ps
  until [[ $1 == -- ]]; do
    case $1 in
      --scrub-ip)   shift; XSOS_SCRUB_IP_HN=y ;;
      --scrub-mac)  shift; XSOS_SCRUB_MACADDR=y ;;
      -6|--ipv6)    shift; XSOS_IP_VERSION=6 ;;
      -q|--wwid)    _OPT_CHECK "wwid" "$2" anystring
                      XSOS_MULTIPATH_QUERY=$2; shift 2
                    ;;
      -u|--unit)    _OPT_CHECK "unit" "$2" string "b k m g t"
                      XSOS_MEM_UNIT=$2; XSOS_NET_UNIT=$2; shift 2
                    ;;
      --threads)    shift; XSOS_PS_THREADS=y ;;
      -v|--verbose) _OPT_CHECK "verbose" "$2" range "0 4"
                      XSOS_PS_LEVEL=$2; shift 2
                    ;;
      -w|--width)   _OPT_CHECK "width" "$2" regex '^[0-9]*$|^w$'
                      XSOS_FOLD_WIDTH=$2; shift 2
                    ;;
      -x|--nocolor) shift; XSOS_COLORS=n     ;;
      -y|--less)    shift; XSOS_OUTPUT_HANDLER='less -SR' ;;
      -z|--more)    shift; XSOS_OUTPUT_HANDLER='more'     ;;
      --rhsupport)  shift; XSOS_OS_RHT_CENTRIC=y          ;;
      -a|--all)     shift; opts=y; all=y     ;;
      -b|--bios)    shift; opts=y; bios=y    ;;
      -o|--os)      shift; opts=y; os=y      ;;
      -k|--kdump)   shift; opts=y; kdump=y   ;;
      -c|--cpu)     shift; opts=y; cpu=y     ;;
      -f|--intrupt) shift; opts=y; intrupt=y ;;
      -m|--mem)     shift; opts=y; mem=y     ;;
      -d|--disks)   shift; opts=y; disks=y   ;;
      -t|--mpath)   shift; opts=y; mpath=y   ;;
      -l|--lspci)   shift; opts=y; lspci=y   ;;
      -e|--ethtool) shift; opts=y; ethtool=y ;;
      -r|--softirq) shift; opts=y; softirq=y ;;
      -n|--netdev)  shift; opts=y; netdev=y  ;;
      -g|--bonding) shift; opts=y; bonding=y ;;
      -i|--ip)      shift; opts=y; ip=y      ;;
      -s|--sysctl)  shift; opts=y; sysctl=y  ;;
      -p|--ps)      shift; opts=y; ps=y      ;;
      --net)        shift; opts=y; lspci=y; ethtool=y; softirq=y; netdev=y; ip=y; bonding=y ;;
      
      --B)  sfile[B]=$2; shift 2 ;;
      --F)  sfile[F]=$2; shift 2 ;;
      --C)  sfile[C]=$2; shift 2 ;;
      --M)  sfile[M]=$2; shift 2 ;;
      --D)  sfile[D]=$2; shift 2 ;;
      --T)  sfile[T]=$2; shift 2 ;;
      --L)  sfile[L]=$2; shift 2 ;;
      --R)  sfile[R]=$2; shift 2 ;;
      --N)  sfile[N]=$2; shift 2 ;;
      --G)  sfile[G]=$2; shift 2 ;;
      --I)  sfile[I]=$2; shift 2 ;;
      --P)  sfile[P]=$2; shift 2 ;;
    esac
  done
  shift #(to get rid of the '--')
  # Set sosroot
  sosroot=$1
}

# Call the parser
PARSE $(getopt -u --name=xsos -o $sopts -l $lopts -- "$@")

# If any special option was used appropriately with a file, do that instead of other opts
if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
  :
# If BASH is not v4+ and special options were used, fail
elif [[ $BASH_VERSINFO -lt 4 && -n $sfile ]]; then
  echo "Special options require use of BASH associative arrays" >&2
  echo "i.e., BASH v4.0 or higher (RHEL6/Fedora11 and above)" >&2
  exit 32
# Use default view if no content options specified
elif [[ -z $opts ]]; then
  for module in $XSOS_DEFAULT_VIEW; do eval $module=y; done
# Else, if "all" option specified, set full view
elif [[ -n $all ]]; then
  for module in $XSOS_ALL_VIEW; do eval $module=y; done
fi

# If color should be enabled, taste the rainbow
if [[ $XSOS_COLORS == y && $BASH_VERSINFO -ge 4 ]]; then
  c[0]=${c[$XSOS_COLOR_RESET]}
  c[H1]=${c[$XSOS_COLOR_H1]}
  c[H2]=${c[$XSOS_COLOR_H2]}
  c[H3]=${c[$XSOS_COLOR_H3]}
  c[H4]=${c[$XSOS_COLOR_H4]}
  c[Imp]=${c[$XSOS_COLOR_IMPORTANT]}
  c[Warn1]=${c[$XSOS_COLOR_WARN1]}
  c[Warn2]=${c[$XSOS_COLOR_WARN2]}
  c[Up]=${c[$XSOS_COLOR_IFUP]}
  c[Down]=${c[$XSOS_COLOR_IFDOWN]}
  c[MemUsed]=${c[$XSOS_COLOR_MEMGRAPH_MEMUSED]}
  c[HugePages]=${c[$XSOS_COLOR_MEMGRAPH_HUGEPAGES]}
  c[Buffers]=${c[$XSOS_COLOR_MEMGRAPH_BUFFERS]}
  c[Cached]=${c[$XSOS_COLOR_MEMGRAPH_CACHED]}
  c[Dirty]=${c[$XSOS_COLOR_MEMGRAPH_DIRTY]}
else
  unset c
fi

# Properly setup fold setting
if [[ $XSOS_FOLD_WIDTH == w ]]; then
  if tty &>/dev/null; then
    XSOS_FOLD_WIDTH=$(( $(tput cols) - 8 ))
  else
    XSOS_FOLD_WIDTH=80
  fi
elif [[ $XSOS_FOLD_WIDTH == 0 ]]; then
  XSOS_FOLD_WIDTH=99999
fi

#-------------------------------------------------------------------------------
# BLEH
# Eventually I'll probably replace all of this with a python loader.
# Python's argparse is so much better than dealing with all this crap.

# Used to check for existence of files on a sosreport and print errors to stderr
SOS_CHECKFILE() {
  local module firstfile
  # $1: module name, e.g. bios, os, cpu, mem
  # $2+: file names, i.e. potential files to be found in sosreport root
  module=$1; shift; firstfile=$1
  # If module needs to be called, check for files
  if [[ $(eval echo \$$module) == y ]]; then
    while [[ $# -gt 0 ]]; do
      # If ethtool module being called, do something specific
      if [[ $module == ethtool ]] && ls "$sosroot"/$1 &>/dev/null; then
          return  # Return successfully if ethtool files found
      # If file ends in slash, look for dir
      elif [[ $1 =~ /$ ]]; then
        [[ -d $sosroot/$1 ]] && return  # Return successfully if dir found
      else
        [[ -r $sosroot/$1 ]] && return  # Return successfully if file readable
      fi
      shift
    done
  else
    return  # If module doesn't need to be called, return success
  fi
  # If we're still here, a module for which we don't have files was requested -- warn
  echo -e "${c[Warn2]}Warning:${c[Warn1]} '$sosroot/$firstfile' file unreadable; skipping $module check${c[0]}" >&2
  echo -en $XSOS_HEADING_SEPARATOR >&2
  return 1
}

# Used to source modules
IMPORT() {
  local module=${1} dir IFS=:
  shift
  for dir in ${XSOS_IMPORT_PATH}; do
    source ${dir}/${module} 2>/dev/null && return
  done
  echo -e "${c[Warn2]}ERROR:${c[Warn1]} To use the ${module} module, one of the \$XSOS_IMPORT_PATH dirs must contain '${module}'" >&2
  echo -e "Current value of \$XSOS_IMPORT_PATH: '${XSOS_IMPORT_PATH}'${c[0]}" >&2
  cat >&2 <<\EOF
  
Your choices:
  * cd to the dir you downloaded xsos to & run it there via ./xsos
  * Copy or symlink the xsos/modules dir to one of the dirs mentioned above
  * Copy/symlink specific (desired) modules to one of the dirs mentioned above
  * Change the $XSOS_IMPORT_PATH env variable to point to an xsos module dir
    This can be done at runtime, e.g.:
      XSOS_IMPORT_PATH=~/git/xsos/modules xsos -ya
    Or it can be done by editing your shell environment, e.g.:
      echo 'export XSOS_IMPORT_PATH=$HOME/git/xsos/modules' >>~/.bash_profile
EOF
  exit 16
}

# Used to source and execute a content module (e.g., BIOS, CPU, MEM)
x() {
  local module=${1}
  shift
  IMPORT ${module}
  ${module} "${@}"
}

# Used to conditionally run certain functions when running on localhost
COND_RUN() {
  local module=$1 cmd=
  case $module in
    BIOS) cmd=dmidecode  ;;
    MPATH) cmd=multipath ;;
    LSPCI) cmd=lspci     ;;
    ETHTOOL) cmd=ethtool ;;
  esac
  if [[ $2 == --require_root && $UID != 0 ]]; then
    echo -e "${c[Warn2]}Warning:${c[Warn1]} Need root access to run $cmd command on localhost${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  elif command -v $cmd &>/dev/null; then
    x $module
  else
    echo -e "${c[Warn2]}Warning:${c[Warn1]} $cmd command not present in PATH${c[0]}" >&2
    echo -en $XSOS_HEADING_SEPARATOR >&2
  fi
}

# Create sub tempdir in /dev/shm (tons of bash constructs use TMPDIR)
[[ -d /dev/shm && -w /dev/shm ]] && parent=/dev/shm || parent=/tmp
export TMPDIR=$(mktemp -d -p $parent)
# Create tmp file for capturing stderr
stderr_file=$TMPDIR/stderr
# Remove temp dir when we're done
trap "rm -rf $TMPDIR 2>/dev/null" EXIT

{
  # Redirect stderr to temp file
  exec 7>&2 2>$stderr_file
  
  # If special options and files were provided ....
  if [[ $BASH_VERSINFO -ge 4 && -n ${sfile[*]} ]]; then
    [[ -r ${sfile[B]} ]] && x BIOS      "${sfile[B]}"
    [[ -r ${sfile[C]} ]] && x CPU       "${sfile[C]}"
    [[ -r ${sfile[F]} ]] && x INTRUPT   "${sfile[F]}"
    [[ -r ${sfile[M]} ]] && x MEM       "${sfile[M]}"
    [[ -r ${sfile[D]} ]] && x DISKS     "${sfile[D]}" --no-mpath
    [[ -r ${sfile[T]} ]] && x MPATH     "${sfile[T]}"
    [[ -r ${sfile[L]} ]] && x LSPCI     "${sfile[L]}"
    [[ -r ${sfile[R]} ]] && x SOFTIRQ   "${sfile[R]}"
    [[ -r ${sfile[N]} ]] && x NETDEV    "${sfile[N]}"
    [[ -r ${sfile[G]} ]] && x BONDING   "${sfile[G]}"
    [[ -r ${sfile[I]} ]] && x IP        "${sfile[I]}"
    [[ -r ${sfile[P]} ]] && x PS        "${sfile[P]}"

  # If SOSREPORT-ROOT provided, use that
  elif [[ -n $sosroot ]]; then
    SOS_CHECKFILE bios    {,sos_commands/kernel.}dmidecode     && x BIOS      "$sosroot"
    SOS_CHECKFILE os      "proc/"                              && x OS        "$sosroot"
    SOS_CHECKFILE kdump   ""                                   && x KDUMP     "$sosroot"
    SOS_CHECKFILE cpu     "proc/cpuinfo"                       && x CPU       "$sosroot"
    SOS_CHECKFILE intrupt "proc/interrupts"                    && x INTRUPT   "$sosroot"
    SOS_CHECKFILE mem     "proc/meminfo"                       && x MEM       "$sosroot"
    SOS_CHECKFILE disks   "proc/partitions"                    && x DISKS     "$sosroot"
    SOS_CHECKFILE mpath   "sos_commands/devicemapper/multipath_-v4_-ll" \
                                                               && x MPATH     "$sosroot"
    SOS_CHECKFILE lspci   "lspci"                              && x LSPCI     "$sosroot"
    SOS_CHECKFILE ethtool "sos_commands/networking/ethtool*"   && x ETHTOOL   "$sosroot"
    SOS_CHECKFILE softirq "proc/net/softnet_stat"              && x SOFTIRQ   "$sosroot"
    SOS_CHECKFILE netdev  "proc/net/dev"                       && x NETDEV    "$sosroot"
    SOS_CHECKFILE bonding "proc/net/bonding/"                  && x BONDING   "$sosroot"
    SOS_CHECKFILE ip      "sos_commands/networking/ip_address" && x IP        "$sosroot"
    SOS_CHECKFILE sysctl  "proc/sys/"                          && x SYSCTL    "$sosroot" 2>/dev/null
    SOS_CHECKFILE ps      "ps"                                 && x PS        "$sosroot"
    
  # If no SOSREPORT-ROOT provided, run checks against local system
  else
    [[ -n $bios ]]    && COND_RUN BIOS --require_root
    [[ -n $os ]]      && x OS /
    [[ -n $kdump ]]   && x KDUMP /
    [[ -n $cpu ]]     && x CPU /
    [[ -n $intrupt ]] && x INTRUPT /
    [[ -n $mem ]]     && x MEM /
    [[ -n $disks ]]   && x DISKS /
    [[ -n $mpath ]]   && COND_RUN MPATH --require_root
    [[ -n $lspci ]]   && COND_RUN LSPCI
    [[ -n $ethtool ]] && COND_RUN ETHTOOL --require_root
    [[ -n $softirq ]] && x SOFTIRQ /
    [[ -n $netdev ]]  && x NETDEV /
    [[ -n $bonding ]] && x BONDING /
    [[ -n $ip ]]      && x IP
    [[ -n $sysctl ]]  && x SYSCTL / 2>/dev/null
    [[ -n $ps ]]      && x PS

  fi
  
  # If sending output to less or more, let's just append stderr to stdout
  # If just outputting to term (cat), redirect fd2 to tty
  case $XSOS_OUTPUT_HANDLER in
    less*|more)  cat $stderr_file ;;
    cat)         exec 2>&7
  esac

} | $XSOS_OUTPUT_HANDLER

# If output going to term (cat), print stderr tmp file contents to stderr
[[ $XSOS_OUTPUT_HANDLER == cat ]] && cat $stderr_file >&2 || :
