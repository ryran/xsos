#!/bin/bash

PS() {
  # Local vars:
  local ps_input_procs ps_input_thrds_raw ps_input_thrds num_sleepers_procs=? num_zombies_procs=? num_sleepers_thrds=? num_zombies_thrds=? ps_input noun top_threads_ps_header top_threads ps_header num_top_users num_comm_args num_process_lines process_line_length Dsleepers Zombies msg_sleepers_thrds msg_zombies_thrds top_users top_users_header
  
  # Get input from proper place dependent on what was passed
  if [[ -z $1 ]]; then
    ps_input_thrds_raw=$(ps auxm)
    ps_input_procs=$(ps aux)
  elif [[ -f $1 ]]; then
    # If passed a single file
    if [[ $XSOS_PS_THREADS == y ]]; then
      ps_input_thrds_raw=$(<"$1")
    else
      ps_input_procs=$(<"$1")
    fi
  else
    ps_input_thrds_raw=$(<"$1/sos_commands/process/ps_auxwwwm")
    ps_input_procs=$(<"$1/ps")
  fi
  # Need to protect any percent signs by doubling them up
  if [[ -n $ps_input_procs ]]; then
    ps_input_procs=$(sed '1!s/%/%%/g' <<<"$ps_input_procs")
    num_sleepers_procs=$(gawk 'BEGIN{n=0} $8~/D/{n++} END{print n}' <<<"$ps_input_procs")
    num_zombies_procs=$(gawk 'BEGIN{n=0} $8~/Z/{n++} END{print n}' <<<"$ps_input_procs")
  fi
  if [[ -n $ps_input_thrds_raw ]]; then
    ps_input_thrds_raw=$(sed '1!s/%/%%/g' <<<"$ps_input_thrds_raw")
    num_sleepers_thrds=$(gawk 'BEGIN{n=0} $8~/D/{n++} END{print n}' <<<"$ps_input_thrds_raw")
    num_zombies_thrds=$(gawk 'BEGIN{n=0} $8~/Z/{n++} END{print n}' <<<"$ps_input_thrds_raw")
    if [[ $XSOS_PS_THREADS != y ]]; then
      [[ $num_sleepers_thrds -gt $num_sleepers_procs ]] && msg_sleepers_thrds="\n$XSOS_INDENT_H2${c[Warn1]}Blocked threads detected; run with --threads option for full detail${c[0]}"
      [[ $num_zombies_thrds -gt $num_zombies_procs ]] && msg_zombies_thrds="\n$XSOS_INDENT_H2${c[Warn1]}Defunct threads detected; run with --threads option for full detail${c[0]}"
    fi
    # Threads in ps m output show with "-" for PID ($2) and COMMAND ($11), so let's fix that
    ps_input_thrds=$(
      gawk '
        {
          if ($2=="-") {
            $2 = pid; $11 = "[thread_of_pid_"pid"]"
          }
          else pid = $2
          print
        }
      ' <<<"$ps_input_thrds_raw"
    )
  fi
  
  if [[ $XSOS_PS_THREADS == y ]]; then
    noun="threads"
    ps_input=$ps_input_thrds
  else
    noun="processes"
    ps_input=$ps_input_procs
  fi
  
  # Verbosity? We den need no stinkin' verbosity!
  if [[ $XSOS_PS_LEVEL == 0 ]]; then
    # V-level 0: Less than default
    num_top_users=3
    num_comm_args=0
    num_process_lines=5
    process_line_length=100
  elif [[ -z $XSOS_PS_LEVEL || $XSOS_PS_LEVEL == 1 ]]; then
    # V-level 1: Default
    num_top_users=10
    num_comm_args=2
    num_process_lines=10
    process_line_length=150
  elif [[ $XSOS_PS_LEVEL == 2 ]]; then
    # V-level 2: Verbose
    num_top_users=30
    num_comm_args=10
    num_process_lines=30
    process_line_length=512
  elif [[ $XSOS_PS_LEVEL == 3 ]]; then
    # V-level 3: MOOOAAAARR
    num_top_users=60
    num_comm_args=1023
    num_process_lines=60
    process_line_length=2047  # This is the max that `column` can handle
  elif [[ $XSOS_PS_LEVEL == 4 ]]; then
    # V-level 4: Eerrryting
    num_top_users=
    num_comm_args=1023
    num_process_lines=
    process_line_length=2047  # This is the max that `column` can handle
  fi
  
  __conditional_head() {
  [[ -n $1 ]] &&
    echo head -n$1 ||
    echo cat
  }
  
  # First, we need to convert VSZ & RSS in the ps input to MiB or GiB (if necessary)
  # We also need to perfectly columnize the input and chop off extra command args based on above options
  _convert_and_columize() {
    gawk -vMAX_fields=$((num_comm_args+12)) -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
      BEGIN {
        # Not going to worry about down-converting to bytes or up-converting to TiB
        if      (u == "B") u = "K"
        else if (u == "T") u = "G"
        else if (u == "K" || u == "G") u = u
        else u = "M"
        
        # Figure out what number to divide by to end up with KiB or MiB or GiB
        if      (u == "K") divisor = 1
        else if (u == "M") divisor = 1024
        else if (u == "G") divisor = 1024 ** 2
        
        # Set pretty printing unit
        U = u"iB"
      }
      NR==1 {
        if ($1=="USER")
          j = 0
        else if ($1=="#") {
          j = 1
          MAX_fields ++
        }
        fieldvsz = j + 5
        fieldrss = j + 6
        fieldtty = j + 7
        fieldcmd = j + 11
      }
      {
        # Print fields up through %MEM
        for (i=1; i<fieldvsz; i++)
          printf $i"❚"
        
        # Print fields VSZ & RSS
        for (i=fieldvsz; i<fieldtty; i++) {
          if      (NR == 1)  printf "%s-%s❚", $i, U
          else if (u == "G") printf "%.1f❚", $i/divisor
          else               printf "%.0f❚", $i/divisor
        }
        
        # Print fields up through TIME
        for (i=fieldtty; i<fieldcmd; i++)
          printf $i"❚"
        
        # For the last field (command) we need to chop things up
        for (i=fieldcmd; i<=NF && i<MAX_fields; i++)
          printf $i" "
        printf "\n"
      }
    ' <<<"$1" | cut -c-$process_line_length | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,"
  }
  
  ps_input=$(_convert_and_columize "$ps_input")
  # Deal with header
  ps_header=$(head -n1 <<<"$ps_input")
  ps_input=$(tail -n+2 <<<"$ps_input")
  
  if [[ -n $ps_input_thrds_raw ]]; then
    # Let's get a count of how many threads each PID has
    top_threads=$(
      gawk '
        NR==1 {
          printf "# %s\n", $0
        }
        NR>1 {
          if ($2 ~ /^[0-9]+$/) {
            pid = $2
            line[pid] = $0
          }
          else if ($2 == "-") {
            nthreads[pid] ++
          }
          else
            pid = "NULL"
        }
        END {
          for (pid in line)
            printf ("%d %s\n", nthreads[pid], line[pid]) | "sort -rn"
        }
      ' <<<"$ps_input_thrds_raw"
    )
    top_threads=$(_convert_and_columize "$top_threads")
    top_threads_ps_header=$(head -n1 <<<"$top_threads")
    top_threads="${c[H3]}$top_threads_ps_header${c[0]}\n$(tail -n+2 <<<"$top_threads" | $(__conditional_head $num_process_lines))"
  else
    top_threads="$XSOS_INDENT_H2${c[DGREY]}[No thread info]${c[0]}"
  fi
  
  # Format and prepare sleeping/zombie processes
  Dsleepers=$(gawk -vcolor_warn="${c[Warn1]}" -vc_0="${c[0]}" '$8~/D/ {print color_warn $0 c_0}' <<<"$ps_input")
  Zombies=$(gawk -vc_grey="${c[DGREY]}" -vc_0="${c[0]}" '$8~/Z/ {print c_grey $0 c_0}' <<<"$ps_input")
  if [[ -n $Dsleepers ]]; then
    Dsleepers="${c[H3]}$ps_header${c[0]}\n$Dsleepers$msg_sleepers_thrds"
  else
    Dsleepers="$XSOS_INDENT_H2${c[DGREY]}[None]${c[0]}$msg_sleepers_thrds"
  fi
  if [[ -n $Zombies ]]; then
    Zombies="${c[H3]}$ps_header${c[0]}\n$Zombies$msg_zombies_thrds"
  else
    Zombies="$XSOS_INDENT_H2${c[DGREY]}[None]${c[0]}$msg_zombies_thrds"
  fi
  
  # Calculate top cpu-using & mem-using users
  if [[ $XSOS_PS_LEVEL < 3 ]]; then  # If verbosity level 0-2, restrict number of users shown
    # Process ps input to generate summary user-list of top-users
    top_users=$(
      gawk -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
        BEGIN { print "USER❚%CPU❚%MEM❚RSS" }
        { pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6 }
        END {
          # Figure out what number to divide by to end up with GiB
          if      (u == "K") divisor = 1024 ** 2
          else if (u == "M") divisor = 1024
          else if (u == "G") divisor = 1
          for (user in pCPU)
            # Only show if greater than 0% CPU and 0.1% MEM
            if (pCPU[user]>0 || pMEM[user]>0.1)
              printf "%s❚%.1f%%❚%.1f%%❚%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/divisor
        }
      ' <<<"$ps_input" | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,")
    # Grab header from the top
    top_users_header=$(head -n1 <<<"$top_users")
  
  else  # If verbosity level 3-4, show all users
    # Process ps input to generate summary user-list of top-users
    top_users=$(
      gawk -vu=$(tr '[:lower:]' '[:upper:]' <<<"$XSOS_PS_UNIT") '
        BEGIN { print "USER❚%CPU❚%MEM❚RSS" }
        { pCPU[$1]+=$3; pMEM[$1]+=$4; sRSS[$1]+=$6 }
        END {
          # Figure out what number to divide by to end up with GiB
          if      (u == "K") divisor = 1024 ** 2
          else if (u == "M") divisor = 1024
          else if (u == "G") divisor = 1
          for (user in pCPU)
            printf "%s❚%.1f%%❚%.1f%%❚%.2f GiB\n", user, pCPU[user], pMEM[user], sRSS[user]/divisor
        }
      ' <<<"$ps_input" | column -ts❚ | sed "s,^,$XSOS_INDENT_H2,")
    # Grab header from the top
    top_users_header=$(head -n1 <<<"$top_users")
  fi
  
  # Remove header from the top and sort everything else by %CPU, potentially trimming down list
  top_users=$(tail -n+2 <<<"$top_users" | sort -rnk2 | $(__conditional_head $num_top_users))
    ps_input=$(tail -n+2 <<<"$ps_input")
  
  # Print!
  echo -e "${c[H1]}PS CHECK${c[0]}
$XSOS_INDENT_H1${c[H2]}Total number of threads/processes:${c[0]} \n$XSOS_INDENT_H2${c[Imp]}$(tail -n+2 <<<"$ps_input_thrds" | wc -l) / $(tail -n+2 <<<"$ps_input_procs" | wc -l)${c[0]}
$XSOS_INDENT_H1${c[H2]}Top users of CPU & MEM:${c[0]} \n${c[H3]}$top_users_header${c[0]} \n$top_users
$XSOS_INDENT_H1${c[H2]}Uninteruptible sleep threads/processes ($num_sleepers_thrds/$num_sleepers_procs):${c[0]} \n$Dsleepers
$XSOS_INDENT_H1${c[H2]}Defunct zombie threads/processes ($num_zombies_thrds/$num_zombies_procs):${c[0]} \n$Zombies
$XSOS_INDENT_H1${c[H2]}Top CPU-using ${noun}:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk3 <<<"$ps_input" | $(__conditional_head $num_process_lines))
$XSOS_INDENT_H1${c[H2]}Top MEM-using ${noun}:${c[0]} \n${c[H3]}$ps_header${c[0]} \n$(sort -rnk6 <<<"$ps_input" | $(__conditional_head $num_process_lines))
$XSOS_INDENT_H1${c[H2]}Top thread-spawning processes:${c[0]} \n$top_threads"
  echo -en $XSOS_HEADING_SEPARATOR
}
